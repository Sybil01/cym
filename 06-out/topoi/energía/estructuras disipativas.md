[[Ilya Prigogine]]

## [[Convexión de Raleigh-Benard]]
- Benard descubre que al calentar una fina capa de líquido se generan estructuras simetricas
- A partir de un flujo constante de calor.
- Si la diferencia de temperatura entre la superficie y el fondo alcanza un valor crítico el flujo de calor es reemplazado por una *convexión térmica*.
- Aquí aparece un patrón ordenado de células hexagonales.
- A medida que el sistema se aleja del equilibrio (de un estado de temperatura uniforme) a traves del líquido , alanza un punto crítico de inestabilidad (inestabilidad de Benard). 
- Es el ejemplo paradigmático de autoorganización,.

algunas consecuencias:
1. todo está en constante cambio y fluctuación.
2. todo en la naturaleza se encuentra en un estado dialéctico-metabólico.
3. Las estructuras disipativas, como todo sistema abierto, se caracterizan por un continuo cambio de energia con el entorno que lo rodea y en permanente flujicidad. (ej.: O2 →  CO2 en humanos ).

## Segundo principio
- los sistemas vivos y no vivos asi como reacciones químicas, son estructuras disipativas, es decir, que se manitenen por una continua disipación o consumo de energía. 

## Tercer principio
- A mayor complejidad de la estructura disipativa mayor energía, y mayor vulnerabilidad de las fluctuaciones internas. (ej. esperma+óvulo genera una estructura (Cigoto) mayor a la suma de las partes, el cigoto se vuelve vulnerable a las fluctuaciones y cada vez necesitará mas recursos)

## Cuarto principio (de inestabilidad)
- A mayor coherencia, aumenta la inestabilidad, la cual es clave para la traosnformación del sistema. (ej, neuronas, muestran una interconexión , red propia de sistema de alta complejidad, cuando ocurre una sinapsis todo el sistema se altera.)

## Quinto Principio (de fluctuaciones)
- Son producto del continuo movimiento de energía a través del sistema, creando nuevas interacciones y conexiones.  (ej. el mar como permanente flujo y permanente fluctuaciones que dan lugar a mayores interacciones)

## Sexto principio (de auto-organización)
- Reorganización de las partes, creando un orden superior. Más integrado y conectado que el anterior, exigiendo mas fluojo de energía, lo que lo hace a su vez, menos estable, y así , sucesivamente. 


---


Es uno de los experimentos donde se ve literalmente *nacer el orden a partir del desorden*, y sintetiza perfectamente los seis principios de la teoría de Prigogine: disipación, complejidad, inestabilidad, fluctuación, autoorganización e irreversibilidad.


1. Origen del experimento

El fenómeno fue estudiado primero por Lord Rayleigh (1916) desde la teoría hidrodinámica, y más tarde desarrollado experimentalmente por Bénard (1900–1901). En el experimento, un fluido se calienta desde abajo: cuando la diferencia de temperatura $\Delta T$ supera un umbral, el gradiente de densidad vuelve inestable la capa y aparecen celdas convectivas hexagonales.
El número de Rayleigh $Ra$ controla la transición:

$$Ra = \frac{g , \beta , (T_b - T_t) , d^3}{\nu , \kappa}$$

donde $g$ es la gravedad, $\beta$ el coeficiente de expansión térmica, $d$ el espesor de la capa, $\nu$ la viscosidad y $\kappa$ la difusividad térmica.
Si $Ra < Ra_c \approx 1708$, el sistema está en equilibrio conductivo (sin movimiento); si $Ra > Ra_c$, el sistema entra en régimen de autoorganización.

---

2. El rol de Prigogine
- Prigogine no realizó los experimentos directamente.
- Basó su teoría en la observación de sistemas reales como las celdas de Bénard, las reacciones oscilatorias químicas (como la Belousov–Zhabotinsky) y los láseres.
- Su trabajo fue teórico y matemático, aunque profundamente inspirado por esos experimentos.
- Su mérito fue formalizar el marco termodinámico capaz de describir cómo estos sistemas podían tener orden estable lejos del equilibrio, algo que la termodinámica clásica (de Clausius o Boltzmann) no podía explicar.

Prigogine trabajó sobre ecuaciones de balance entrópico, desarrolló la idea de “producción de entropía mínima” cerca del equilibrio y estructuras disipativas lejos del equilibrio.
Sus colaboraciones con Paul Glansdorff fueron decisivas: juntos publicaron “Thermodynamic Theory of Structure, Stability and Fluctuations” (1971), donde derivan el criterio de estabilidad de estructuras disipativas.

---

3. Relación entre teoría y experimento

El experimento de Rayleigh–Bénard fue clave para confirmar empíricamente que:
- El sistema exporta entropía al entorno ($\Phi>0$).
- Las fluctuaciones térmicas se amplifican cuando el sistema se aleja del equilibrio.
- Surge una estructura espacialmente ordenada (celdas hexagonales) sin un “plan” externo: el orden emerge del flujo disipativo.
- Cuando se corta el calentamiento, las celdas desaparecen: el orden es irreversible y dependiente del flujo de energía.

En términos de Prigogine, el sistema realiza una transición de bifurcación: múltiples estados posibles, seleccionados por pequeñas fluctuaciones iniciales.
Esa sensibilidad al estado inicial es lo que da la flecha del tiempo: el patrón elegido no puede revertirse espontáneamente.

---

4. Por qué es un ejemplo completo

La convección de Bénard muestra los seis principios de la termodinámica del no-equilibrio:

Principio	Manifestación en el experimento
Disipación	El gradiente térmico genera flujo de calor continuo.
Inestabilidad	Por encima del número crítico de Rayleigh, el estado estable (conductivo) se vuelve inestable.
Fluctuación	Pequeñas perturbaciones térmicas se amplifican.
Autoorganización	Surgen celdas hexagonales periódicas.
Complejidad	Interacción no lineal entre conducción, convección y viscosidad.
Irreversibilidad	Al enfriar, las celdas se disuelven; el camino de retorno no es simétrico.


---

5. Analogía musical

Podrías decir que un instrumento autooscilante o de feedback controlado funciona igual que la célula de Bénard:
- la energía (entrada) es el flujo que mantiene el sistema lejos del equilibrio,
- el patrón sonoro es la estructura disipativa,
- la autoorganización ocurre cuando las retroalimentaciones entran en fase,
- y la irreversibilidad se manifiesta en que el proceso musical no puede “volver atrás”: solo se sostiene mientras haya flujo energético.


## caso El laser 

Excelente pregunta —y muy buena conexión con vector synthesis, porque el láser es un ejemplo de libro de estructura disipativa oscilatoria que, en sentido amplio, comparte el mismo tipo de dinámica no lineal y autoorganizada que se busca en los sistemas de síntesis paramétrica o vectorial.

Vamos paso a paso:

---

1. El láser como sistema disipativo

El láser (Light Amplification by Stimulated Emission of Radiation) es un sistema fuera del equilibrio termodinámico.
- Requiere un bombeo energético constante (óptico o eléctrico).
- Posee un medio activo (átomos, iones, moléculas o semiconductores) con niveles de energía excitados.
- Tiene una cavidad resonante que selecciona modos coherentes del campo electromagnético.
- Y una disipación controlada por los espejos que dejan salir parte del campo.

En resumen, el láser se autoorganiza entre ganancia y pérdida, manteniendo un estado estacionario de coherencia que sólo existe mientras hay flujo de energía:

$$\frac{dN}{dt} = P - \frac{N}{\tau} - g N I$$
$$\frac{dI}{dt} = g N I - \frac{I}{T_c}$$

donde
- $N$ es la población excitada,
- $I$ la intensidad del campo,
- $P$ la potencia de bombeo,
- $\tau$ el tiempo de relajación de los átomos,
- $T_c$ el tiempo de vida del campo en la cavidad,
- y $g$ el coeficiente de ganancia.

Estas ecuaciones (similares a las de Lotka–Volterra) describen la dinámica no lineal entre población y radiación, y son formalmente análogas a las ecuaciones de autoosciladores químicos o biológicos.

---

2. Quién hizo los experimentos
- El primer láser fue realizado por Theodore Maiman (1960) en Hughes Research Labs, usando un cristal de rubí.
- Luego Ali Javan construyó el primer láser de helio–neón continuo (1961).
- Los experimentos de comportamiento caótico y de bifurcaciones en láseres fueron desarrollados más tarde (década de 1970–80) por investigadores como Haken, Graham, Haken–Weidlich y Nicolis–Prigogine, quienes estudiaron su comportamiento como sistema autoorganizado.

Hermann Haken fue el primero en formalizar el láser dentro de la “Synergetics”, una teoría de los sistemas cooperativos no lineales muy afín a Prigogine, y colaboró indirectamente con su grupo en Bruselas. Haken llamó al láser “un ejemplo paradigmático de estructura disipativa coherente”.

---

3. Por qué el láser encaja en la teoría de Prigogine

El láser es un sistema de no-equilibrio mantenido por bombeo, en el cual:
- se exporta entropía (calor disipado, radiación incoherente),
- el orden (coherencia de fase) emerge a partir de fluctuaciones espontáneas del campo,
- y la transición al umbral de láser ($P>P_{\text{th}}$) es una bifurcación hacia un estado de menor entropía local.

El láser, en palabras de Prigogine, “produce orden temporal y espacial a partir de la disipación misma”.
Es, literalmente, un “orden termodinámico nacido del desorden”.

---

4. Relación con vector synthesis

En vector synthesis (o síntesis vectorial, en el sentido de acoplar y mezclar fuentes en un espacio paramétrico), el comportamiento deseado es precisamente un espacio de estados dinámicos donde el sonido emerge como un equilibrio móvil entre varios flujos o moduladores.

La analogía láser–vector synthesis es profunda:

Aspecto físico	Equivalente musical
Flujo de bombeo $P$	Energía de excitación (amplitud, modulación, feedback)
Población invertida $N$	Acumulación de energía o tensión sonora
Campo óptico coherente $I$	Señal musical organizada (timbre estable)
Espejos / cavidad resonante	Filtros o retardos que seleccionan modos
Bifurcación de umbral	Paso del ruido al tono (aparición de forma sonora)
Ruido cuántico de arranque	Fluctuaciones iniciales o random seed
Saturación de ganancia	Compresión dinámica o estabilización tímbrica

En otras palabras, un sintetizador vectorial bien diseñado podría operar como un láser sonoro, donde los distintos osciladores son “modos de cavidad” y la energía de modulación actúa como bombeo.
El estado estacionario es una coherencia dinámica entre componentes: no equilibrio, pero estabilidad.

---

5. Ejemplo conceptual aplicable

Podrías imaginar un sistema de síntesis vectorial gobernado por ecuaciones tipo láser:

$$
\begin{cases}
\dot{x}i = G_i(E)x_i - \gamma_i x_i + \sum_j K{ij}(x_j - x_i) \
\dot{E} = P - \sum_i G_i(E)x_i^2 - \kappa E
\end{cases}
$$

donde:
-  son las amplitudes o modos sonoros,
- $E$ la “energía” global del sistema (flujo de control, ganancia),
- $G_i(E)$ la ganancia dependiente del campo (saturación),
- $K_{ij}$ el acoplamiento vectorial entre modos,
- y $\kappa$ la disipación global.

Esto produciría autooscilaciones estabilizadas y “bifurcaciones sonoras” similares a la transición láser, pero en el dominio del timbre.
Una implementación podría hacerse en WebAudio o Max/MSP simulando los umbrales de ganancia y acoplamiento.

---

6. En resumen
- Prigogine no construyó láseres, pero su teoría explica su comportamiento como estructura disipativa.
- El grupo de Haken y Nicolis sí lo integró explícitamente al marco de la termodinámica del no-equilibrio.
- En términos organológicos, el láser es un arquetipo de instrumento autoorganizado, y su dinámica matemática puede inspirar modelos de síntesis vectorial basada en flujo y disipación —una suerte de laser synth que “lasea” sonido en lugar de luz.



```dataviewjs
// Laser→Vector Synthesis minimal en DataviewJS (Obsidian)
// Autooscilador con umbral (bombeo vs disipación) y 4 “modos” acoplados.
// Ecuaciones discretizadas:
//   ẋ_i = G(E)*x_i - γ x_i + K Σ_j (x_j - x_i) + η·ξ
//   Ė    = P - Σ_i G(E) x_i^2 - κ E
//   con G(E) = g0 / (1 + α E)
// UI: Start/Stop + sliders; canvas muestra E (línea) y |x_i| (barras).

const root = this.container || dv.container; root.innerHTML = "";
const el = Object.assign(document.createElement("div"), {style: "font:13px/1.3 system-ui,Segoe UI,Roboto; color: var(--text-normal);"});
root.appendChild(el);

// UI helpers
const mk = (tag, attrs={}, parent=el)=>{const n=document.createElement(tag);Object.assign(n,attrs);parent.appendChild(n);return n;};
const row = mk("div",{style:"display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:.5rem 0;"});
const btnStart = mk("button",{textContent:"Start",style:"padding:.4rem .8rem;border:1px solid var(--background-modifier-border);background:var(--background-secondary);border-radius:6px;cursor:pointer;"},row);
const btnStop  = mk("button",{textContent:"Stop",style:"padding:.4rem .8rem;border:1px solid var(--background-modifier-border);background:var(--background-secondary);border-radius:6px;cursor:pointer;opacity:.6;"},row);

const sliders = mk("div",{style:"display:grid;grid-template-columns:repeat(3,minmax(220px,1fr));gap:.5rem;"}); el.appendChild(sliders);
const makeSlider=(label,min,max,step,val)=>{
  const wrap=mk("label",{style:"display:flex;align-items:center;gap:.5rem;background:var(--background-secondary);padding:.4rem .6rem;border-radius:6px;border:1px solid var(--background-modifier-border);"});
  const span=mk("span",{textContent:`${label}: ${val.toFixed(3)}`,style:"min-width:130px;white-space:nowrap;"},wrap);
  const inp=mk("input",{type:"range",min,max,step,value:String(val),style:"flex:1;"},wrap);
  inp.addEventListener("input",()=>{span.textContent=`${label}: ${(+inp.value).toFixed(3)}`;});
  sliders.appendChild(wrap);
  return ()=>+inp.value;
};

const getP      = makeSlider("P (bombeo)",0,2,0.001,0.45);
const getg0     = makeSlider("g0 (ganancia)",0,3,0.001,1.4);
const getAlpha  = makeSlider("α (saturación)",0,3,0.001,0.9);
const getGamma  = makeSlider("γ (pérdida)",0,2,0.001,0.4);
const getK      = makeSlider("K (acople)",0,1,0.001,0.18);
const getKappa  = makeSlider("κ (disipación E)",0,2,0.001,0.35);
const getNoise  = makeSlider("η (ruido)",0,0.2,0.0005,0.01);
const getAmp    = makeSlider("Out gain",0,1,0.001,0.25);
const getBaseHz = makeSlider("Base Hz",20,800,1,120);
const getSpc    = makeSlider("Detune spread",0,50,0.1,12);

// Canvas
const can = mk("canvas",{width:900,height:220,style:"width:100%;height:auto;border:1px solid var(--background-modifier-border);border-radius:6px;background:var(--background-primary);margin-top:.5rem;"});
el.appendChild(can);
const cx = can.getContext("2d");

// Estado del modelo
const N = 4;
let x = Array.from({length:N},(_,i)=>0.001*(i+1)); // arranque
let E = 0.02;
let running = false, rafId=null, stepId=null;

// Audio
let AC=null, master=null, modes=[], modeGains=[];
function setupAudio(){
  AC = AC || new (window.AudioContext||window.webkitAudioContext)();
  master = AC.createGain(); master.gain.value = 0; master.connect(AC.destination);
  modes = []; modeGains = [];
  for(let i=0;i<N;i++){
    const osc = AC.createOscillator();
    const g = AC.createGain();
    osc.type = "sine";
    osc.frequency.value = getBaseHz()*(1 + (i-(N-1)/2)*getSpc()/1000);
    osc.connect(g).connect(master);
    osc.start();
    modes.push(osc); modeGains.push(g);
  }
}

// Dinámica y render
function tick(dt){
  const P = getP(), g0=getg0(), alpha=getAlpha(), gamma=getGamma(), K=getK(), kappa=getKappa(), eta=getNoise();
  const G = g0/(1+alpha*E);
  // acople
  const sumX = x.reduce((a,b)=>a+b,0);
  const nx = new Array(N);
  for(let i=0;i<N;i++){
    const coupling = K*(sumX - N*x[i]);
    const noise = eta*(Math.random()*2-1);
    const dx = (G*x[i] - gamma*x[i] + coupling + noise);
    nx[i] = x[i] + dt*dx;
  }
  // energía
  const sumPow = nx.reduce((a,b)=>a + (G*b*b),0);
  const dE = (P - sumPow - kappa*E);
  E = Math.max(0, E + dt*dE);
  x = nx.map(v=>isFinite(v)?v:0);

  // audio mapping
  if(master){
    master.gain.value = getAmp();
    for(let i=0;i<N;i++){
      const a = Math.max(0, Math.min(1, Math.abs(x[i])));
      modeGains[i].gain.value = 0.0005 + 0.3*a; // salida segura
      // microvariación de frecuencia por E para “vida”
      const f0 = getBaseHz()*(1 + (i-(N-1)/2)*getSpc()/1000);
      modes[i].frequency.setTargetAtTime(f0*(1+0.02*(E-0.5)), AC.currentTime, 0.05);
    }
  }
}

function draw(){
  const w=can.width,h=can.height; cx.clearRect(0,0,w,h);
  // grid
  cx.save();
  cx.globalAlpha=0.08; cx.strokeStyle="#888"; cx.beginPath();
  for(let i=0;i<=10;i++){ const y=i*h/10; cx.moveTo(0,y); cx.lineTo(w,y); }
  cx.stroke(); cx.restore();

  // barras |x_i|
  const barW = w/(N+3);
  for(let i=0;i<N;i++){
    const a = Math.max(0,Math.min(1,Math.abs(x[i])));
    const bh = a*(h-40);
    cx.fillStyle = ["#8b5cf6","#22c55e","#f59e0b","#3b82f6"][i%4];
    cx.fillRect(20 + i*(barW+10), h-20-bh, barW, bh);
  }
  // texto barras
  cx.fillStyle="var(--text-normal)"; cx.font="12px system-ui";
  for(let i=0;i<N;i++){
    cx.fillText(`|x${i+1}|=${Math.abs(x[i]).toFixed(3)}`, 20 + i*(barW+10), h-6);
  }
  // energía E como línea
  const Ey = (1-Math.tanh(E))*0.5; // compresión a [0,1]
  const y = 20 + Ey*(h-60);
  cx.strokeStyle="#ef4444"; cx.lineWidth=2; cx.beginPath(); cx.moveTo(0,y); cx.lineTo(w,y); cx.stroke();
  cx.fillStyle="#ef4444"; cx.fillText(`E=${E.toFixed(3)}`, w-90, y-6);
}

function loop(){
  if(!running) return;
  const dt = 0.02; // 50 Hz
  for(let k=0;k<2;k++) tick(dt/2); // subpasos
  draw();
  rafId = requestAnimationFrame(loop);
}

// Start/Stop
btnStart.onclick = async ()=>{
  if(running) return;
  if(!AC) setupAudio();
  if(AC.state==="suspended") await AC.resume();
  running = true; btnStart.style.opacity="1"; btnStop.style.opacity="1";
  loop();
};
btnStop.onclick = ()=>{
  running = false; btnStart.style.opacity="1"; btnStop.style.opacity=".6";
  if(rafId) cancelAnimationFrame(rafId);
};

// Cleanup al cambiar de nota/página
const cleanup = ()=>{
  running = false;
  if(rafId) cancelAnimationFrame(rafId);
  if(stepId) clearInterval(stepId);
  if(modeGains) modeGains.forEach(g=>{try{g.disconnect();}catch{}});
  if(modes) modes.forEach(o=>{try{o.stop();o.disconnect();}catch{}});
  if(master){try{master.disconnect();}catch{}}
  // no cerramos AC para no romper otras vistas
};
window.addEventListener("beforeunload", cleanup);
```




```dataviewjs
// Vector Synthesis (XY) con multiplex entre Lissajous y sólido 3D (proyección) + brillo (Z emulado)
// - X=Left, Y=Right (audio); Z (brillo) visible en canvas (si tu scope no tiene Z)
// - “Fósforo” (persistencia), rotación 3D, crossfade tipo vs-multiplex, Start/Stop seguro
// - Un solo botón toggle; cierra AudioContext al parar

const root=this.container||dv.container; root.innerHTML="";
const ui=Object.assign(document.createElement("div"),{style:"font:13px system-ui;display:grid;gap:.6rem;color:var(--text-normal)"}); root.appendChild(ui);
const row=(...els)=>{const r=document.createElement("div");r.style.cssText="display:flex;flex-wrap:wrap;gap:.5rem;align-items:center";els.forEach(e=>r.appendChild(e));return r;}
const mkLbl=t=>{const s=document.createElement("span");s.textContent=t; s.style.minWidth="120px"; return s;}
const mkSlider=(name,min,max,step,val,fmt=x=>x.toFixed(2))=>{
  const wrap=document.createElement("label"); wrap.style.cssText="display:flex;align-items:center;gap:.6rem;background:var(--background-secondary);padding:.35rem .6rem;border:1px solid var(--background-modifier-border);border-radius:6px;flex:1";
  const cap=mkLbl(`${name}: ${fmt(val)}`); const s=document.createElement("input");
  s.type="range"; s.min=min; s.max=max; s.step=step; s.value=val; s.style.flex=1;
  s.addEventListener("input",()=>cap.textContent=`${name}: ${fmt(+s.value)}`); wrap.append(cap,s); return [wrap,()=>+s.value,s,cap];
};
const mkSel=(name,opts,val)=>{const w=document.createElement("label"); w.style.cssText="display:flex;align-items:center;gap:.6rem;padding:.35rem .6rem;border:1px solid var(--background-modifier-border);border-radius:6px;"; const sp=mkLbl(name); const s=document.createElement("select"); for(const o of opts){const op=document.createElement("option");op.value=o;op.textContent=o; if(o===val) op.selected=true; s.appendChild(op);} w.append(sp,s); return [w,()=>s.value,s];}
const mkChk=(name,checked=false)=>{const w=document.createElement("label"); w.style.cssText="display:flex;align-items:center;gap:.5rem;padding:.35rem .6rem;border:1px solid var(--background-modifier-border);border-radius:6px;"; const i=document.createElement("input"); i.type="checkbox"; i.checked=checked; const sp=document.createElement("span"); sp.textContent=name; w.append(i,sp); return [w,()=>i.checked,i];}

const btn=document.createElement("button"); btn.textContent="Start"; btn.style.cssText="padding:.5rem .9rem;border:1px solid var(--background-modifier-border);background:var(--background-secondary);border-radius:8px;cursor:pointer;min-width:110px";
ui.appendChild(row(btn));

const [selShape,getShape]=mkSel("shape 3D",["cube","icosa"],"cube");
const [sRotX,getRotX]=mkSlider("rotX °",-180,180,0.1,25,(x)=>x.toFixed(1));
const [sRotY,getRotY]=mkSlider("rotY °",-180,180,0.1,35,(x)=>x.toFixed(1));
const [sRotZ,getRotZ]=mkSlider("rotZ °",-180,180,0.1,0,(x)=>x.toFixed(1));
const [sScale,getScale]=mkSlider("escala 3D",0.1,1.2,0.001,0.7,(x)=>x.toFixed(3));

const [sLF,getLF]=mkSlider("Liss fX Hz",0.1,2000,0.01,220,(x)=>x.toFixed(2));
const [sRF,getRF]=mkSlider("Liss fY Hz",0.1,2000,0.01,330,(x)=>x.toFixed(2));
const [sPhase,getPhase]=mkSlider("Liss fase °",0,360,0.1,0,(x)=>x.toFixed(1));
const [sLType,getLType]=mkSel("Liss forma",["sine","sawtooth","triangle","square"],"sine");

const [sMux,getMux]=mkSlider("multiplex (Liss→3D)",0,1,0.001,0.0,(x)=>x.toFixed(3));
const [sBright,getBright]=mkSlider("brillo Z",0,1,0.001,0.9,(x)=>x.toFixed(3));
const [sPersist,getPersist]=mkSlider("fósforo",0,0.25,0.001,0.08,(x)=>x.toFixed(3));
const [sAmp,getAmp]=mkSlider("amplitud out",0,1,0.001,0.6,(x)=>x.toFixed(3));
const [sBaseHz,getBaseHz]=mkSlider("rate (points/sim)",100,6000,10,2400,(x)=>x.toFixed(0));
const [chkAA,isAA]=mkChk("antialias canvas",true);

ui.append(row(selShape,sRotX,sRotY,sRotZ,sScale));
ui.append(row(sLF,sRF,sPhase,sLType));
ui.append(row(sMux,sBright,sPersist,sAmp,sBaseHz,chkAA));

const canvas=document.createElement("canvas"); canvas.width=900; canvas.height=540;
canvas.style.cssText="width:100%;height:auto;border:1px solid var(--background-modifier-border);border-radius:8px;background:black";
ui.appendChild(canvas);
const ctx=canvas.getContext("2d");

// Estado
let running=false, raf=null, t0=performance.now()/1000; let phiX=0, phiY=0;

// WebAudio
let AC=null, oscLX=null, oscLY=null, gL=null, gR=null, comp=null;

// Limpia AC colgante global
if(window.__vecAC && window.__vecAC.state!=="closed"){ try{await window.__vecAC.close();}catch{} window.__vecAC=null; }

// Utilidades
function wave(type,ph){ const p=ph%(2*Math.PI); switch(type){
  case "sine": return Math.sin(p);
  case "triangle": return 2/Math.PI*Math.asin(Math.sin(p));
  case "square": return Math.sign(Math.sin(p));
  case "sawtooth": return 2*(p/(2*Math.PI))-1;
  default: return Math.sin(p);
}}
function rot3([x,y,z],rx,ry,rz){
  const cx=Math.cos(rx), sx=Math.sin(rx), cy=Math.cos(ry), sy=Math.sin(ry), cz=Math.cos(rz), sz=Math.sin(rz);
  // Rx
  let X=x, Y= y*cx - z*sx, Z= y*sx + z*cx;
  // Ry
  let X2= X*cy + Z*sy, Y2=Y, Z2= -X*sy + Z*cy;
  // Rz
  return [ X2*cz - Y2*sz, X2*sz + Y2*cz, Z2 ];
}
function proj([x,y,z],s){ const d=1.2; const k=s/(d - z*0.8); return [x*k,y*k]; }

// Geometrías
function geoCube(){
  const a=0.6; const v=[[-a,-a,-a],[a,-a,-a],[a,a,-a],[-a,a,-a],[-a,-a,a],[a,-a,a],[a,a,a],[-a,a,a]];
  const e=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
  return {v,e};
}
function geoIco(){ // aproximación regular
  const t=(1+Math.sqrt(5))/2, s=0.5/Math.sqrt(1+t*t);
  const V=[[ -s, t*s,0],[ s, t*s,0],[-s,-t*s,0],[ s,-t*s,0],[0,-s, t*s],[0, s, t*s],[0,-s,-t*s],[0, s,-t*s],[ t*s,0,-s],[ t*s,0, s],[-t*s,0,-s],[-t*s,0, s]];
  const E=[[0,5],[0,7],[0,11],[1,5],[1,7],[1,9],[2,4],[2,6],[2,11],[3,4],[3,6],[3,9],[4,5],[4,11],[5,9],[6,7],[6,8],[7,8],[8,9],[8,10],[9,10],[10,11],[10,7],[11,8]];
  return {v:V,e:E};
}

// Audio
function setupAudio(){
  AC=new (window.AudioContext||window.webkitAudioContext)(); window.__vecAC=AC;
  // Dos osciladores → mapeados a X e Y con control de ganancia
  const oscX=AC.createOscillator(), oscY=AC.createOscillator();
  oscX.type="sine"; oscY.type="sine";
  gL=AC.createGain(); gR=AC.createGain(); gL.gain.value=0; gR.gain.value=0;
  comp=AC.createDynamicsCompressor();
  oscX.connect(gL).connect(comp); oscY.connect(gR).connect(comp); comp.connect(AC.destination);
  oscX.start(); oscY.start();
  oscLX=oscX; oscLY=oscY;
}
async function destroyAudio(){
  try{ if(oscLX){try{oscLX.stop();}catch{} try{oscLX.disconnect();}catch{}} if(oscLY){try{oscLY.stop();}catch{} try{oscLY.disconnect();}catch{}} if(gL){try{gL.disconnect();}catch{}} if(gR){try{gR.disconnect();}catch{}} if(comp){try{comp.disconnect();}catch{}} }catch{}
  try{ if(AC && AC.state!=="closed"){ await AC.close(); } }catch{}
  oscLX=oscLY=gL=gR=comp=null; if(window.__vecAC===AC) window.__vecAC=null; AC=null;
}

// Render loop
function draw(){
  if(!running) return;
  const now=performance.now()/1000, dt=now-t0; t0=now;
  // persistencia
  ctx.globalCompositeOperation="source-over";
  ctx.fillStyle=`rgba(0,0,0,${getPersist()})`; ctx.fillRect(0,0,canvas.width,canvas.height);
  const W=canvas.width,H=canvas.height,cx=W/2, cy=H/2;
  if(isAA()){ ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality="high"; } else { ctx.imageSmoothingEnabled=false; }

  // Señal Lissajous
  const fX=getLF(), fY=getRF(), phase=getPhase()*Math.PI/180;
  phiX += 2*Math.PI*fX*dt; phiY += 2*Math.PI*fY*dt;
  const steps=Math.max(200, Math.min(8000, Math.floor(getBaseHz()*dt)));
  const A = Math.min(W,H)*0.42*getAmp();
  const lissPts=[];
  for(let i=0;i<steps;i++){
    const t=i/steps*2*Math.PI;
    const x=A*wave(getLType(), phiX+t);
    const y=A*wave(getLType(), phiY+t+phase);
    lissPts.push([x,y,1.0]); // z=1 (brillo)
  }

  // Geometría 3D proyectada a XY
  const rx=getRotX()*Math.PI/180, ry=getRotY()*Math.PI/180, rz=getRotZ()*Math.PI/180, sc=getScale();
  const geo = (getShape()==="cube") ? geoCube() : geoIco();
  // puntos muestreados a lo largo de las aristas
  const segs=64; const vecPts=[];
  for(const [a,b] of geo.e){
    const va=geo.v[a], vb=geo.v[b];
    for(let s=0;s<=segs;s++){
      const u=s/segs;
      const p=[ va[0]*(1-u)+vb[0]*u, va[1]*(1-u)+vb[1]*u, va[2]*(1-u)+vb[2]*u ];
      const r=rot3(p,rx,ry,rz); const [X,Y]=proj(r, sc*Math.min(W,H)*0.42*getAmp()/1.2);
      // brillo por cara aproximado: mayor cuando Z “mira” al frente
      const z=r[2]; const bright = 0.5+0.5*Math.max(-1,Math.min(1, z));
      vecPts.push([X,Y,bright]);
    }
  }

  // Multiplex entre Lissajous y Vector 3D
  const mux=getMux(), bright=getBright();
  const N=Math.min(lissPts.length, vecPts.length);
  ctx.save(); ctx.translate(cx,cy);
  ctx.beginPath();
  for(let i=0;i<N;i++){
    const a=lissPts[i], b=vecPts[i];
    const x=(1-mux)*a[0] + mux*b[0];
    const y=(1-mux)*a[1] + mux*b[1];
    const z=(1-mux)*a[2] + mux*b[2]; // brillo
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    // eje de brillo como estela modulada
    const g = Math.max(0, Math.min(1, z*bright));
    ctx.strokeStyle=`rgba(120,255,200,${0.15+0.85*g})`;
  }
  ctx.stroke();
  ctx.restore();

  // Actualiza audio (solo dos canales → X,Y); brillo puede mapearse a ganancia si querés “blanking”
  if(AC){
    const mapHz = (hz)=>Math.max(10, Math.min(18000, hz));
    const fx = (1-mux)*mapHz(getLF()) + mux*mapHz(140);   // 3D: tono fijo para XY estable
    const fy = (1-mux)*mapHz(getRF()) + mux*mapHz(220);
    if(oscLX && oscLY){ oscLX.frequency.setTargetAtTime(fx, AC.currentTime, 0.01); oscLY.frequency.setTargetAtTime(fy, AC.currentTime, 0.01); }
    const g = Math.min(0.9,getAmp());
    if(gL&&gR){ gL.gain.setTargetAtTime(g, AC.currentTime, 0.02); gR.gain.setTargetAtTime(g, AC.currentTime, 0.02); }
  }

  raf=requestAnimationFrame(draw);
}

// Toggle
btn.onclick = async ()=>{
  if(!running){
    // start
    try{ await destroyAudio(); setupAudio(); if(AC.state==="suspended") await AC.resume(); }catch(e){ console.error(e); }
    running=true; btn.textContent="Stop"; t0=performance.now()/1000; draw();
  }else{
    // stop
    running=false; if(raf) cancelAnimationFrame(raf); await destroyAudio(); btn.textContent="Start";
  }
};

// Limpieza al cambiar de nota/página
window.addEventListener("beforeunload", async ()=>{ try{running=false;if(raf)cancelAnimationFrame(raf); await destroyAudio();}catch{} });
```



1. Técnica: síntesis vectorial y representación XY

En esta técnica, dos señales analógicas (o digitales, en este caso dos canales de audio) controlan directamente la deflexión del haz de un osciloscopio o proyector láser:
	•	el canal izquierdo (L) mueve el haz horizontalmente (X)
	•	el derecho (R) lo mueve verticalmente (Y)
	•	y un tercer canal (opcional) regula el brillo o “blanking” (Z)

Esto se conoce como síntesis vectorial o oscilografía XY. A diferencia de la rasterización moderna (que barre líneas fijas y discretiza la imagen en píxeles), aquí la figura surge del movimiento continuo del haz, directamente guiado por la señal de audio.
El resultado es un sistema físicamente acoplado, donde la geometría y el sonido son literalmente la misma energía en distinta dimensión: eléctrica, visual y acústica.

Cada figura —un Lissajous, un sólido 3D rotante, o una forma modulada por sonido— es la expresión visible de un campo oscilatorio dinámico.
Como todo campo dinámico, este sistema sólo puede sostener su forma mediante un flujo continuo de energía (alimentación eléctrica, oscilación estable) y la disipación de parte de esa energía (calor en los componentes, luz que se dispersa).

⸻

2. Relación con estructuras disipativas (Prigogine)

Prigogine describió las estructuras disipativas como configuraciones ordenadas que surgen fuera del equilibrio termodinámico, sostenidas por flujos constantes de energía y materia.
El sistema XY es exactamente eso:

Elemento	Equivalente en teoría disipativa
Señales de audio X,Y	Flujos de energía oscilante (forzamiento)
Proyección o haz láser	Medio donde se manifiesta el orden
Retroalimentación entre señales (modulación, multiplex)	No linealidad del sistema
Calor, ruido, decaimiento del haz	Disipación entrópica
Patrón visual estable	Estructura de autoorganización
Corte de energía → desaparición de la figura	Retorno al equilibrio (pérdida del orden)

En otras palabras, la figura vectorial es una estructura disipativa visual:
aparece, se sostiene y desaparece con la energía que la alimenta.
No puede existir en reposo ni puede revertir su proceso una vez disipado el flujo: el haz no puede “reconstruir” la figura anterior exactamente.

⸻

3. Principio de irreversibilidad

En la termodinámica clásica, la irreversibilidad se mide por el aumento de entropía.
En la síntesis vectorial, el paralelismo es conceptual:
	•	cada trazo del haz consume energía eléctrica y produce calor y fotones;
	•	cuando el sistema se apaga, esa energía ya fue disipada;
	•	incluso si reactivás la figura, el punto de partida no será idéntico —pequeñas fluctuaciones (fases, latencias, ruido térmico, jitter) hacen que el recorrido nunca sea igual.

Por tanto, no hay simetría temporal: el haz no puede reescribir el mismo pasado, sólo generar variaciones.
Esto se alinea perfectamente con el pensamiento de Prigogine: la irreversibilidad no es un defecto del sistema, sino su condición de posibilidad para generar forma.

El orden existe porque el tiempo fluye en una sola dirección.
Sin disipación, no habría música ni figura: sólo equilibrio, es decir, silencio.

⸻

4. Ejemplo práctico de irreversibilidad

pequeña simulación de decaimiento entrópico —un sistema que nunca repite exactamente su estado anterior, aunque siga una regla determinista.
El siguiente bloque DataviewJS ilustra esto con un “campo de puntos” que se enfría y nunca vuelve a su configuración inicial:


```dataviewjs

// Ejemplo: irreversibilidad visual — disipación de energía en un campo simple
// Cada frame: los puntos pierden energía y se reorganizan (no hay estado reversible)
const root=this.container; root.innerHTML="";
const c=document.createElement("canvas"); c.width=600;c.height=300;
c.style.cssText="width:100%;height:auto;background:black;border-radius:8px"; root.appendChild(c);
const ctx=c.getContext("2d");

let particles=Array.from({length:300},()=>({x:Math.random()*c.width,y:Math.random()*c.height,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*2,e:1}));

function step(){
  ctx.fillStyle="rgba(0,0,0,0.15)"; ctx.fillRect(0,0,c.width,c.height);
  for(const p of particles){
    p.x+=p.vx; p.y+=p.vy;
    p.e*=0.995; // disipación
    if(p.x<0||p.x>c.width){p.vx*=-1;}
    if(p.y<0||p.y>c.height){p.vy*=-1;}
    const col=`hsl(${(1-p.e)*220+140},80%,${p.e*70}%)`;
    ctx.fillStyle=col;
    ctx.beginPath(); ctx.arc(p.x,p.y,1.5,0,2*Math.PI); ctx.fill();
    // fluctuación: ruido térmico
    p.vx+=(Math.random()-0.5)*0.02;
    p.vy+=(Math.random()-0.5)*0.02;
  }
  requestAnimationFrame(step);
}
step();

```


Cada punto es una “partícula” con energía $e(t)$ que decae lentamente:
	•	el sistema pierde energía con cada frame (disipación),
	•	introduce pequeñas fluctuaciones aleatorias (ruido),
	•	y nunca vuelve a un estado anterior exacto (irreversibilidad).

no existe “rollback”: sólo historia.

⸻

5. En síntesis

La síntesis vectorial es una metáfora tecnológica perfecta del principio prigoginiano:
	•	convierte energía en forma;
	•	mantiene orden mediante disipación;
	•	y existe únicamente en la irreversibilidad del tiempo.

Cuando se apaga el osciloscopio o detenés el AudioContext, el sistema vuelve al equilibrio: el patrón desaparece, el tiempo sigue, y la forma se vuelve recuerdo —exactamente como sucede en toda estructura disipativa del universo, de las células a las sinfonías.