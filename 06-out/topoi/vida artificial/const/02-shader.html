<!doctype html>
<meta charset="utf-8">
<title>spherical + filtered pink noise — 2025</title>
<style>
  html,
  body {
    margin: 0;
    height: 100%;
    background: #000
  }

  canvas {
    display: block
  }
</style>
<canvas id=c></canvas>
<script>
  // spherical + filtered pink noise — 2025
  const d = document, c = d.getElementById('c'); c.width = innerWidth; c.height = innerHeight;
  const gl = c.getContext('webgl2'), vs = `#version 300 es
in vec2 p; out vec2 uv; void main(){uv=p*.5+.5; gl_Position=vec4(p,0.,1.);} `,
    fs = `#version 300 es
precision highp float; out vec4 o; uniform float t; uniform vec2 r;
void main(){
  vec2 u=(gl_FragCoord.xy/r.y)*3.1415926535;
  vec3 a=vec3(0.); a+=.57;
  vec3 c=vec3(sin(u.x+vec2(0.,11.))*sin(u.y),cos(u.y));
  vec3 v=mix(dot(a,c)*a,c,sin(t))+cos(t)*cross(a,c);
  o=vec4(tanh(.1/abs(tan(v/.1))),1.);
}`;
  const H = t => { const s = gl.createShader(t.k); gl.shaderSource(s, t.s); gl.compileShader(s); return s },
    P = (() => {
      const p = gl.createProgram(); gl.attachShader(p, H({ k: gl.VERTEX_SHADER, s: vs }));
      gl.attachShader(p, H({ k: gl.FRAGMENT_SHADER, s: fs })); gl.linkProgram(p); return p
    })(),
    T = gl.getUniformLocation(P, 't'), R = gl.getUniformLocation(P, 'r'),
    B = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, B);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
  gl.useProgram(P); const a = gl.getAttribLocation(P, 'p'); gl.enableVertexAttribArray(a); gl.vertexAttribPointer(a, 2, gl.FLOAT, false, 0, 0);
  const draw = t => { gl.viewport(0, 0, c.width = c.clientWidth, c.height = c.clientHeight); gl.uniform1f(T, t * .001); gl.uniform2f(R, c.width, c.height); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); requestAnimationFrame(draw) }; requestAnimationFrame(draw);

  // audio: deterministic pink noise → bandpass → highpass → reverb (50% wet) → gain
  const seed = { x: 123456789 }, rnd = () => { seed.x ^= seed.x << 13; seed.x ^= seed.x >>> 17; seed.x ^= seed.x << 5; return (seed.x >>> 0) / 4294967295 };
  d.addEventListener('click', (() => {
    const A = new AudioContext(),
    G = new GainNode(A, { gain: .08 }), BP = new BiquadFilterNode(A, { type: 'bandpass', Q: 2, frequency: 280 }),
    HP = new BiquadFilterNode(A, { type: 'highpass', frequency: 22 }),
    REV = A.createConvolver(), DG = new GainNode(A, { gain: .5 }), WG = new GainNode(A, { gain: .5 }),
    imp = A.createBuffer(1, A.sampleRate * 2, A.sampleRate), data = imp.getChannelData(0);
    for (let i = 0; i < data.length; i++)data[i] = (rnd() * 2 - 1) * Math.pow(1 - i / data.length, 3);
    REV.buffer = imp;
    N = A.createScriptProcessor(1024, 0, 1), S = { b0: 0, b1: 0, b2: 0, b3: 0, b4: 0, b5: 0, b6: 0 };
    N.onaudioprocess = (e => {
      const o = e.outputBuffer.getChannelData(0);
      o.forEach((_, i) => {
        const w = rnd() * 2 - 1;
        S.b0 = 0.99886 * S.b0 + w * 0.0555179; S.b1 = 0.99332 * S.b1 + w * 0.0750759;
        S.b2 = 0.96900 * S.b2 + w * 0.1538520; S.b3 = 0.86650 * S.b3 + w * 0.3104856;
        S.b4 = 0.55000 * S.b4 + w * 0.5329522; S.b5 = -0.7616 * S.b5 - w * 0.0168980;
        o[i] = (S.b0 + S.b1 + S.b2 + S.b3 + S.b4 + S.b5 + S.b6 * 0.5362) * 0.11; S.b6 = w * 0.115926;
      });
    });
    N.connect(BP).connect(HP);
    HP.connect(DG).connect(G);
    HP.connect(REV).connect(WG).connect(G);
    G.connect(A.destination);
    (() => { const k = () => { const t = A.currentTime; BP.frequency.value = 180 + 160 * Math.sin(t * .35) + 110 * Math.sin(t * .07); G.gain.value = .06 + .02 * Math.sin(t * .5); requestAnimationFrame(k) }; k() })()
  }), { once: true });
</script>